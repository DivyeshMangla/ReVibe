generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Employee {
  id            String         @id @default(uuid())
  empCode       String         @unique
  name          String
  email         String         @unique
  department    String
  hireDate      DateTime
  status        EmployeeStatus @default(ACTIVE)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  jobProfiles      JobProfile[]
  salarySlips      SalarySlip[]
  promotions       Promotion[]
  leaves           Leave[]
  transfers        Transfer[]
  trainings        Training[]
  acrs             ACR[]
  evaluations      Evaluation[]
  joiningRelieving JoiningRelieving[]
  eServiceBooks    EServiceBook[]
  propertyReturns  PropertyReturn[]

  @@map("employees")
}

model JobProfile {
  id               String   @id @default(uuid())
  employeeId       String
  role             String
  department       String
  responsibilities String   @db.Text
  effectiveDate    DateTime
  createdAt        DateTime @default(now())

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@map("job_profiles")
  @@index([employeeId, effectiveDate])
}

model PayrollRun {
  id          String          @id @default(uuid())
  month       Int
  year        Int
  status      PayrollStatus   @default(DRAFT)
  createdBy   String
  approvedBy  String?
  finalizedBy String?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  salarySlips SalarySlip[]

  @@unique([month, year])
  @@map("payroll_runs")
}

model SalarySlip {
  id            String   @id @default(uuid())
  employeeId    String
  payrollRunId  String
  basicSalary   Float
  hra           Float    @default(0)
  da            Float    @default(0)
  otherEarnings Float    @default(0)
  pf            Float    @default(0)
  esi           Float    @default(0)
  tds           Float    @default(0)
  otherDeductions Float  @default(0)
  grossSalary   Float
  netPay        Float
  version       Int      @default(1)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  employee     Employee      @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  payrollRun   PayrollRun    @relation(fields: [payrollRunId], references: [id], onDelete: Cascade)
  corrections  Correction[]

  @@map("salary_slips")
  @@index([employeeId, payrollRunId])
}

model Correction {
  id            String           @id @default(uuid())
  salarySlipId  String
  requestedBy   String
  reason        String           @db.Text
  changes       Json
  status        CorrectionStatus @default(PENDING)
  approvedBy    String?
  rejectedBy    String?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  salarySlip SalarySlip @relation(fields: [salarySlipId], references: [id], onDelete: Cascade)

  @@map("corrections")
  @@index([salarySlipId, status])
}

model Promotion {
  id              String           @id @default(uuid())
  employeeId      String
  currentRole     String
  proposedRole    String
  currentSalary   Float
  proposedSalary  Float
  salaryIncrease  Float
  reason          String           @db.Text
  status          PromotionStatus  @default(PENDING)
  effectiveDate   DateTime
  requestedBy     String
  approvedBy      String?
  rejectedBy      String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@map("promotions")
  @@index([employeeId, status])
}

model ChatMessage {
  id        String   @id @default(uuid())
  userId    String
  message   String   @db.Text
  response  String?  @db.Text
  timestamp DateTime @default(now())

  @@map("chat_messages")
  @@index([userId, timestamp])
}

enum EmployeeStatus {
  ACTIVE
  INACTIVE
  TERMINATED
}

enum PayrollStatus {
  DRAFT
  APPROVED
  FINALIZED
}

enum CorrectionStatus {
  PENDING
  APPROVED
  REJECTED
}

enum PromotionStatus {
  PENDING
  APPROVED
  REJECTED
  EFFECTIVE
}

model Leave {
  id            String      @id @default(uuid())
  employeeId    String
  leaveType     LeaveType
  startDate     DateTime
  endDate       DateTime
  days          Int
  reason        String      @db.Text
  status        LeaveStatus @default(PENDING)
  appliedAt     DateTime    @default(now())
  approvedBy    String?
  approvedAt    DateTime?
  rejectedBy    String?
  rejectedAt    DateTime?

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@map("leaves")
  @@index([employeeId, status])
}

model Transfer {
  id              String         @id @default(uuid())
  employeeId      String
  fromDepartment  String
  toDepartment    String
  fromLocation    String
  toLocation      String
  reason          String         @db.Text
  effectiveDate   DateTime
  status          TransferStatus @default(PENDING)
  requestedAt     DateTime       @default(now())
  approvedBy      String?
  approvedAt      DateTime?

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@map("transfers")
  @@index([employeeId, status])
}

model Training {
  id              String         @id @default(uuid())
  employeeId      String
  trainingName    String
  trainingType    String
  startDate       DateTime
  endDate         DateTime
  duration        Int
  trainer         String
  status          TrainingStatus @default(SCHEDULED)
  completionDate  DateTime?
  score           Float?
  feedback        String?        @db.Text
  createdAt       DateTime       @default(now())

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@map("trainings")
  @@index([employeeId, status])
}

model ACR {
  id              String    @id @default(uuid())
  employeeId      String
  year            Int
  reviewPeriod    String
  overallRating   Float
  strengths       String    @db.Text
  improvements    String    @db.Text
  goals           String    @db.Text
  reviewerName    String
  reviewerEmail   String
  status          ACRStatus @default(DRAFT)
  submittedAt     DateTime?
  approvedAt      DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@map("acrs")
  @@index([employeeId, year])
}

model Evaluation {
  id              String          @id @default(uuid())
  employeeId      String
  evaluationType  String
  period          String
  overallScore    Float
  technicalScore  Float
  softSkillScore  Float
  punctuality     Float
  teamwork        Float
  comments        String          @db.Text
  evaluatedBy     String
  status          EvaluationStatus @default(DRAFT)
  submittedAt     DateTime?
  createdAt       DateTime        @default(now())

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@map("evaluations")
  @@index([employeeId, period])
}

enum LeaveType {
  SICK
  CASUAL
  EARNED
  MATERNITY
  PATERNITY
  UNPAID
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum TransferStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

enum TrainingStatus {
  SCHEDULED
  ONGOING
  COMPLETED
  CANCELLED
}

enum ACRStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
}

enum EvaluationStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
}

model JoiningRelieving {
  id              String          @id @default(uuid())
  employeeId      String
  type            JRType
  requestDate     DateTime        @default(now())
  effectiveDate   DateTime
  reason          String?         @db.Text
  exitInterview   String?         @db.Text
  clearanceStatus ClearanceStatus @default(PENDING)
  fnfSettlement   Float?
  status          JRStatus        @default(PENDING)
  approvedBy      String?
  approvedAt      DateTime?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@map("joining_relieving")
  @@index([employeeId, type])
}

model EServiceBook {
  id             String   @id @default(uuid())
  employeeId     String
  entryType      String
  entryDate      DateTime
  description    String   @db.Text
  documentUrl    String?
  verifiedBy     String?
  verifiedAt     DateTime?
  createdAt      DateTime @default(now())

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@map("eservice_books")
  @@index([employeeId, entryDate])
}

model PropertyReturn {
  id              String         @id @default(uuid())
  employeeId      String
  itemName        String
  itemCategory    String
  serialNumber    String?
  issuedDate      DateTime
  returnDate      DateTime?
  condition       String?
  status          PropertyStatus @default(ISSUED)
  remarks         String?        @db.Text
  submittedAt     DateTime?
  verifiedBy      String?
  verifiedAt      DateTime?
  createdAt       DateTime       @default(now())

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@map("property_returns")
  @@index([employeeId, status])
}

enum JRType {
  JOINING
  RELIEVING
}

enum JRStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

enum ClearanceStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
}

enum PropertyStatus {
  ISSUED
  RETURNED
  DAMAGED
  LOST
}
